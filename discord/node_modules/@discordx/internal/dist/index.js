"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Decorator: () => Decorator,
  Modifier: () => Modifier,
  decorateAClass: () => decorateAClass,
  getLinkedObjects: () => getLinkedObjects
});
module.exports = __toCommonJS(index_exports);

// src/decorator/util.ts
function getLinkedObjects(a, list) {
  return list.filter((b) => {
    let cond = a.from === b.from && a.key === b.key;
    if (a.index !== void 0 && b.index !== void 0) {
      cond &&= a.index === b.index;
    }
    return cond;
  });
}
function decorateAClass(method) {
  return !method?.value;
}

// src/decorator/classes/Decorator.ts
var Decorator = class {
  _classRef;
  _from;
  _key;
  _method;
  _index;
  /**
   * Gets the index of the parameter being decorated, if applicable.
   */
  get index() {
    return this._index;
  }
  /**
   * Gets or sets the class reference being decorated.
   */
  get classRef() {
    return this._classRef;
  }
  set classRef(value) {
    this._classRef = value;
    this.from = value;
  }
  /**
   * Gets or sets the originating class reference.
   */
  get from() {
    return this._from;
  }
  set from(value) {
    this._from = value;
  }
  /**
   * Gets the key of the property or method being decorated.
   */
  get key() {
    return this._key;
  }
  /**
   * Gets the method descriptor if the target is a method.
   */
  get method() {
    return this._method;
  }
  /**
   * Determines if the target is a class.
   */
  get isClass() {
    return !!this._method;
  }
  /**
   * Decorates an unknown type (class, method, or property).
   * @param classRef - The class reference.
   * @param key - The property key.
   * @param method - The method descriptor.
   * @param index - The parameter index.
   * @returns The current instance.
   */
  decorateUnknown(classRef, key, method, index) {
    const decoratedClass = decorateAClass(method) && index === void 0;
    const finalClassRef = decoratedClass ? classRef : classRef.constructor;
    const finalKey = decoratedClass ? finalClassRef.name : key;
    const finalMethod = decoratedClass ? finalClassRef : method?.value;
    return this.decorate(
      finalClassRef,
      finalKey,
      finalMethod,
      finalClassRef,
      index
    );
  }
  /**
   * Applies the decoration to the specified target.
   * @param classRef - The class reference.
   * @param key - The property key.
   * @param method - The method descriptor.
   * @param from - The originating class reference.
   * @param index - The parameter index.
   * @returns The current instance.
   */
  decorate(classRef, key, method, from, index) {
    this._from = from ?? classRef;
    this._classRef = classRef;
    this._key = key;
    this._method = method;
    this._index = index;
    return this;
  }
};

// src/decorator/classes/Modifier.ts
var Modifier = class _Modifier extends Decorator {
  _toModify;
  _modifyTypes;
  /**
   * Constructor to initialize a modifier.
   * @param toModify - The function to modify the decorator.
   * @param modifyTypes - The list of types that can be modified.
   */
  constructor(toModify, modifyTypes) {
    super();
    this._toModify = toModify;
    this._modifyTypes = modifyTypes;
  }
  /**
   * Creates a new modifier instance.
   * @param toModify - The function to modify the decorator.
   * @param modifyTypes - The list of types that can be modified.
   * @returns A new modifier instance.
   */
  static create(toModify, ...modifyTypes) {
    return new _Modifier(toModify, modifyTypes);
  }
  /**
   * Applies the modifications from a list of modifiers to a list of decorators.
   * @param modifiers - The list of modifiers.
   * @param originals - The list of decorators to modify.
   * @returns A promise that resolves when all modifications are applied.
   */
  static async applyFromModifierListToList(modifiers, originals) {
    await Promise.all(
      modifiers.map(async (modifier) => {
        let linked = getLinkedObjects(modifier, originals);
        linked = linked.filter(
          (linkedOriginal) => modifier._modifyTypes.some((type) => linkedOriginal instanceof type)
        );
        await Promise.all(
          linked.map(
            (linkedOriginal) => modifier.applyModifications(linkedOriginal)
          )
        );
      })
    );
  }
  /**
   * Applies modifications to the specified decorator.
   * @param original - The decorator to modify.
   * @returns The result of the modification function.
   */
  applyModifications(original) {
    return this._toModify(original);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Decorator,
  Modifier,
  decorateAClass,
  getLinkedObjects
});
